<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cecina Babich Morrow on Cecina Babich Morrow</title>
    <link>/</link>
    <description>Recent content in Cecina Babich Morrow on Cecina Babich Morrow</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Goldwater Highlight</title>
      <link>/post/goldwater-highlight/</link>
      <pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/goldwater-highlight/</guid>
      <description>&lt;figure&gt;
  &lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/goldwater_banner.png&#34; /&gt;
&lt;/figure&gt;

&lt;p&gt;This is just a quick post to provide a &lt;a href=&#34;https://twitter.com/GoldwaterSC/status/1163980565978259456&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; to the Goldwater Scholar Social Media Highlight that Nina Singh wrote about me. You can find the pdf to the article &lt;a href=&#34;/goldwater_highlight.pdf&#34;&gt;here&lt;/a&gt;. Huge thanks to the Goldwater social media team for including me in this!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Talk: Delineating parapatric ranges using species distribution models and support vector machines: An example with three-toed sloths (Bradypus)</title>
      <link>/talk/ibs_2019/</link>
      <pubDate>Fri, 09 Aug 2019 00:00:00 -0400</pubDate>
      
      <guid>/talk/ibs_2019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Poster: Improving species range estimates for an arboreal species group with a parapatric distribution</title>
      <link>/talk/mammalogy_2019/</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 -0400</pubDate>
      
      <guid>/talk/mammalogy_2019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Talk: Using SVMs to delineate parapatric ranges: An example with three-toed sloths (Bradypus)</title>
      <link>/talk/helenfellow_june2019/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 -0400</pubDate>
      
      <guid>/talk/helenfellow_june2019/</guid>
      <description>&lt;p&gt;&lt;iframe src=&#34;https://docs.google.com/presentation/d/e/2PACX-1vT29X9rGoq1GeCwrXMPJEhmwy7I_nf8fFzpIMdWyLQfROI-zVqicELakhgOgRWvDgicV3s_c6ii4njc/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Copying R libraries to a USB</title>
      <link>/post/2019-06-07-usb/</link>
      <pubDate>Fri, 07 Jun 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-06-07-usb/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:60%&#34; src=&#34;/img/usb_meme.jpg&#34; /&gt;
&lt;figcaption&gt;
From &lt;a href=&#34;https://www.facebook.com/groups/WildGreenMemesForEcologicalFiends/&#34;&gt;Wild Green Memes for Ecological Fiends&lt;/a&gt;.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div id=&#34;inspiration-for-this-post&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Inspiration for this post&lt;/h2&gt;
&lt;p&gt;A few people in my lab are headed to a workshop in Colombia next week, and due to the possibility of intermittent wi-fi, they need to load all of the workshop materials onto USB drives. They need R with certain packages on the USBs in versions compatible with both Macs and PCs, so I offered to help out by loading my Mac version of R and my packages.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;loading-r-onto-a-usb&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Loading R onto a USB&lt;/h2&gt;
&lt;p&gt;The first step was to copy my installation of R onto the USB. To do this, I just copied R from my Applications folder onto the folder. We are not entirely sure if this will work yet to transfer R to someone else’s computer (if someone knows the answer, let me know!), but we are going to test it out shortly.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;loading-r-packages-onto-a-usb&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Loading R packages onto a USB&lt;/h2&gt;
&lt;p&gt;The next step was to transfer all of my R packages onto the USB. To do this, I first needed to figure out where the packages were saved on my computer. You can run the following in R to find where your packages are saved:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;.libPaths()
## [1] &amp;quot;/Library/Frameworks/R.framework/Versions/3.5/Resources/library&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, I needed to figure out how to navigate to the USB in Terminal. According to this &lt;a href=&#34;https://apple.stackexchange.com/questions/60231/using-terminal-how-can-i-find-which-directory-is-my-usb-drive-mounted-in&#34;&gt;StackOverflow answer&lt;/a&gt;, all drives are mounted in &lt;code&gt;/Volumes&lt;/code&gt;, so I ran the following in Terminal:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cd /Volumes
ls&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From there, I was able to see &lt;code&gt;USB DISK&lt;/code&gt; as one of the folders in &lt;code&gt;/Volumes&lt;/code&gt;. In order to copy all of the packages from my computer onto the USB, I used &lt;code&gt;cp&lt;/code&gt; to move everything from the folder found in &lt;code&gt;.libPaths()&lt;/code&gt; onto the USB:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# replace the first file path with what you get from .libPaths()
cp -R /Library/Frameworks/R.framework/Versions/3.5/Resources/library/ /Volumes/USB\ DISK/R_packages/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Setting resolution and aspect ratios in R</title>
      <link>/post/2019-05-23-highres-figures/</link>
      <pubDate>Thu, 23 May 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-05-23-highres-figures/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:60%&#34; src=&#34;/img/resolution_comic.jpg&#34; /&gt;
&lt;figcaption&gt;
Bizarro.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div id=&#34;inspiration-for-this-post&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Inspiration for this post&lt;/h2&gt;
&lt;p&gt;I recently needed to make some figures to present and noticed that the ones I was importing from saved R plots were showing up fuzzy on the presentation. Shortly afterwards, I had interns trying to generate figures with the same aspect ratio from different computers. I did a little digging and found this method for saving figures with specified resolutions and aspect ratios.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;solution&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;In order to save your figure with a certain size and resolution, you just need to include your code for plotting between the two lines below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# To save a .png file:
png(&amp;quot;your_image.png&amp;quot;, units = &amp;quot;in&amp;quot;, width = 5, height = 4, res = 300)
# your plotting code here
dev.off()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also save .bmp, .jpeg, and .tiff files in the same way with the &lt;code&gt;bmp&lt;/code&gt;, &lt;code&gt;jpeg&lt;/code&gt; and &lt;code&gt;tiff&lt;/code&gt; functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;To see this in practice, we can plot some data from the iris dataset the “regular” way:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pairs(iris[,1:4], col = iris$Species)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-23-highres-figures_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Things look pretty nice in the plotting window, but when you save that figure from RStudio, this is the result:&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:80%&#34; src=&#34;/img/lowres.png&#34; /&gt;
&lt;/figure&gt;
&lt;p&gt;To get rid of that graininess, we can instead save the figure in the following way:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;png(&amp;quot;highres.png&amp;quot;, units = &amp;quot;in&amp;quot;, width = 5, height = 4, res = 300)
pairs(iris[,1:4], col = iris$Species)
dev.off()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting figure is much clearer and ready to be inserted in presentations or publications!&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:80%&#34; src=&#34;/img/highres.png&#34; /&gt;
&lt;/figure&gt;
&lt;p&gt;You can also change the aspect ratio by modifying the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; arguments. You can leave the units in inches or set it to pixels (&lt;code&gt;&amp;quot;px&amp;quot;&lt;/code&gt;), centimeters (&lt;code&gt;&amp;quot;cm&amp;quot;&lt;/code&gt;), or millimeters (&lt;code&gt;&amp;quot;mm&amp;quot;&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Thresholding species distribution models</title>
      <link>/post/2019-04-12-sdm-threshold/</link>
      <pubDate>Fri, 12 Apr 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-04-12-sdm-threshold/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/thresholds.png&#34; /&gt;
&lt;figcaption&gt;
From left to right: unmodified species distribution model, minimum training presence threshold, and 10th percentile threshold.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div id=&#34;inspiration-for-this-post&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Inspiration for this post&lt;/h2&gt;
&lt;p&gt;Conservation is often the main motivation behind studying where a species lives – having a model of a species’ range can help scientists assess whether it is at risk of extinction, designate protected regions to preserve its habitat, and study potential impacts of human activity. When we create species distribution models using common methods like Maxent, the result is a map of predicted habitat suitability or probability of species presence, such as the one below. In conservation management, however, it is often more useful to present range models in the form of species presence/absence. We can convert continuous predictions of habitat suitability into binary predictions of whether a species lives in a certain region or not using thresholds: i.e. designating all regions above a certain suitability level as within the species range and all areas below that suitability level as outside of it.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:60%&#34; src=&#34;/img/threshold_ex.png&#34; /&gt;
&lt;figcaption&gt;
Left: species distribution model with continuous habitat suitability values. Right: binary presence/absence model used by applying a threshold. (Figure from &lt;a href=&#34;https://rspatial.org/sdm/6_sdm_methods.html#mahalanobis-distance&#34;&gt;Spatial Data Science with R&lt;/a&gt;)
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;I recently needed to threshold some species distribution models to convert them into these binary maps and had difficulty finding a built-in way to do this in R. The &lt;code&gt;dismo&lt;/code&gt; package for species distribution modeling has a function &lt;code&gt;threshold&lt;/code&gt; to find what value to use as the “cut-off”, but I needed a function to apply a given cut-off value to model and output a raster with binary values for presence and absence.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;thresholding-function&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Thresholding function&lt;/h2&gt;
&lt;p&gt;I wrote an R function to take a species distribution model and threshold it by a given threshold - either minimum training presence (MTP) or 10th percentile training present (P10).&lt;/p&gt;
&lt;div id=&#34;minimum-training-presence&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Minimum training presence&lt;/h3&gt;
&lt;p&gt;This threshold finds the lowest predicted suitability value for an occurrence point. Essentially, it assumes that the least suitable habitat at which the species is known to occur is the minimum suitability value for the species. The MTP threshold ensures that all occurrence points fall within the area of the binary model.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;th-percentile-training-presence&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;10th percentile training presence&lt;/h3&gt;
&lt;p&gt;The P10, on the other hand, is a threshold which omits all regions with habitat suitability lower than the suitability values for the lowest 10% of occurrence records. It assumes that the 10% of occurrence records in the least suitable habitat aren’t occurring in regions that are representative of the species overall habitat, and thus should be omitted. This threshold omits a greater region than the MTP.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-function&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The function&lt;/h3&gt;
&lt;p&gt;The following is the function I wrote to apply these two thresholds to an SDM. The function’s arguments are the SDM, the occurrence points of the species in the form of longitude - latitude pairs, the threshold type, and whether the user would like the output to be a binary prediction (0s for predicted absence and 1s for predicted presence), or a thresholded continuous SDM (regions with suitability below the threshold set to 0).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(raster)
## Warning: package &amp;#39;raster&amp;#39; was built under R version 3.5.2
## Loading required package: sp

sdm_threshold &amp;lt;- function(sdm, occs, type = &amp;quot;mtp&amp;quot;, binary = FALSE){
  occPredVals &amp;lt;- raster::extract(sdm, occs)
  if(type == &amp;quot;mtp&amp;quot;){
    thresh &amp;lt;- min(na.omit(occPredVals))
  } else if(type == &amp;quot;p10&amp;quot;){
    if(length(occPredVals) &amp;lt; 10){
      p10 &amp;lt;- floor(length(occPredVals) * 0.9)
    } else {
      p10 &amp;lt;- ceiling(length(occPredVals) * 0.9)
    }
    thresh &amp;lt;- rev(sort(occPredVals))[p10]
  }
  sdm_thresh &amp;lt;- sdm
  sdm_thresh[sdm_thresh &amp;lt; thresh] &amp;lt;- NA
  if(binary){
    sdm_thresh[sdm_thresh &amp;gt;= thresh] &amp;lt;- 1
  }
  return(sdm_thresh)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first step of the function is to extract the SDM predictions at all occurrence points.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;occPredVals &amp;lt;- raster::extract(sdm, occs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, the function calculates a threshold value &lt;code&gt;thresh&lt;/code&gt; for either the MTP or P10 threshold. Finally, it sets all cells in the SDM raster with values lower than the threshold equal to 0. If the user wants a binary map, the function sets all cells above the threshold equal to 1:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sdm_thresh &amp;lt;- sdm
sdm_thresh[sdm_thresh &amp;lt; thresh] &amp;lt;- NA
if(binary){
  sdm_thresh[sdm_thresh &amp;gt;= thresh] &amp;lt;- 1
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;Now we can apply the function to an actual SDM I generated for a species of three-toed sloth (&lt;em&gt;Bradypus variegatus&lt;/em&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load in the SDM and occurrence points
sloth_sdm &amp;lt;- raster(&amp;quot;/Users/hellenfellows/Desktop/website-hugo/static/SDMs/variegatus_sdm.tif&amp;quot;)
sloth_occs &amp;lt;- read.csv(&amp;quot;~/Desktop/website-hugo/static/SDMs/variegatus_occ.csv&amp;quot;)

plot(sloth_sdm)
points(sloth_occs[,2:3], pch = 19, cex = 0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can apply both MTP and P10 thresholds to the SDM based on the location of the occurrence points:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sloth_mtp &amp;lt;- sdm_threshold(sloth_sdm, sloth_occs[,2:3], &amp;quot;mtp&amp;quot;)
plot(sloth_mtp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
sloth_p10 &amp;lt;- sdm_threshold(sloth_sdm, sloth_occs[,2:3], &amp;quot;p10&amp;quot;)
plot(sloth_p10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-5-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We could also make either of these thresholded SDMs into a binary prediction in the following way:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sloth_mtp_bin &amp;lt;- sdm_threshold(sloth_sdm, sloth_occs[,2:3], &amp;quot;mtp&amp;quot;, binary = TRUE)
plot(sloth_mtp_bin)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;generalization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Generalization&lt;/h2&gt;
&lt;p&gt;My primary motivation to write this function was to use it on SDMs, but the function could easily be generalized to threshold any raster by a given value:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;raster_threshold &amp;lt;- function(input_raster, points = NULL, type = NULL, threshold = NULL, binary = FALSE) {
  if (!is.null(points)) {
    pointVals &amp;lt;- raster::extract(input_raster, points)
    if (type == &amp;quot;mtp&amp;quot;) {
      threshold &amp;lt;- min(na.omit(pointVals))
    } else if (type == &amp;quot;p10&amp;quot;) {
      if (length(pointVals) &amp;lt; 10) {
        p10 &amp;lt;- floor(length(pointVals) * 0.9)
      } else {
        p10 &amp;lt;- ceiling(length(pointVals) * 0.9)
      }
      threshold &amp;lt;- rev(sort(pointVals))[p10]
    }
  }
  raster_thresh &amp;lt;- input_raster
  raster_thresh[raster_thresh &amp;lt; threshold] &amp;lt;- NA
  if (binary) {
    raster_thresh[raster_thresh &amp;gt;= threshold] &amp;lt;- 1
  }
  return(raster_thresh)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I expanded the function to allow the user to input points within the raster to calculate MTP and P10 thresholds if desired, but also to enable a user-specified threshold.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# create arbitrary raster
raster1 &amp;lt;- raster(nrow=10, ncol=10)
raster1[1:25]&amp;lt;- 1:25
raster1[26:50] &amp;lt;- rev(1:25)
raster1[51:75] &amp;lt;- 1:25
raster1[76:100] &amp;lt;- rev(1:25)

# create a set of 20 arbitrary points within the raster
xy &amp;lt;- data.frame(x = runif(20, min = -150, max = 150), y = runif(20, min = -70, max = 70))

plot(raster1)
points(xy)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we can apply the function to see the MTP and P10 thresholded rasters:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtp_raster &amp;lt;- raster_threshold(input_raster = raster1, points = xy, type = &amp;quot;mtp&amp;quot;, binary = TRUE)
plot(mtp_raster)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
p10_raster &amp;lt;- raster_threshold(input_raster = raster1, points = xy, type = &amp;quot;p10&amp;quot;, binary = TRUE)
plot(p10_raster)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-9-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can also use a user-inputted threshold to remove all parts of the raster with values lower than 20:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;user_raster &amp;lt;- raster_threshold(input_raster = raster1, threshold = 20)
plot(user_raster)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-12-sdm-threshold_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Big vs. Small: Using ratios to compare life history strategies</title>
      <link>/talk/brownscholars_ratiotalk_2019/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 -0400</pubDate>
      
      <guid>/talk/brownscholars_ratiotalk_2019/</guid>
      <description>&lt;p&gt;&lt;iframe src=&#34;https://docs.google.com/presentation/d/e/2PACX-1vQ1T_FLUSVOYZ3YCehaGJM7gFCFMOCQMllQ9A4itkVMk5IyUJugfnE8Qt95WqqFMsV5dNintG0qQjU0/embed?&#34; frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Converting alpha hulls to spatial objects</title>
      <link>/post/2019-03-18-alpha-hull/</link>
      <pubDate>Mon, 18 Mar 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-03-18-alpha-hull/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:60%&#34; src=&#34;/img/alpha_bg_regions.png&#34; /&gt;
&lt;figcaption&gt;
Alpha hulls (α = 20) around occurrence points for two species of sloths.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div id=&#34;inspiration-for-this-post&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Inspiration for this post&lt;/h2&gt;
&lt;p&gt;In species distribution modeling, one of the key steps requires the researcher to select a “background region” for the species, i.e. a region over which a machine learning model will compare the environment of the “background points” with the environment at points where the species is known to occur. The key to selecting this region is to pick an area where the species could occur but hasn’t necessarily been observed – for example, you don’t want to include an area separated from the rest of the range by a big mountain range that you don’t believe the organism could cross, but you do want to include a range of potential environments. There are many methods to delineate this region, from drawing a box around the occurrence points of the species to creating a buffered region around each occurrence point (think a collection of lots of circles around each point). One of my research mentors suggested that I try a new method using a shape known as an α-hull.&lt;/p&gt;
&lt;p&gt;I’ll describe α-hulls in more detail below, but you can get the gist from the map above, where I show occurrence points for two species of sloths surrounded by an α-hull for each species. When I tried to create this region in R, however, I ran into a roadblock: the α-hull objects were a specific kind of R object that didn’t play nicely with spatial data in R, particularly objects from the &lt;code&gt;sp&lt;/code&gt; package. In particular, I needed a way to convert α objects into SpatialPolygons. This post describes a series of functions I wrote to carry out this process.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-alphahull-package&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;code&gt;alphahull&lt;/code&gt; package&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;alphahull&lt;/code&gt; R package (Pateiro-Lopez et al. 2016) draws shapes (like the ones above) around sets of points based on a given parameter, α. The package creates two kinds of shapes I was interested in: α-shapes and α-convex hulls. The functions in this post convert these shapes into objects compatible with the &lt;code&gt;sp&lt;/code&gt; package, which can then be used for spatial analyses, including creating background regions for species distribution modeling.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load packages
library(alphahull)
library(sp)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;alpha-shapes&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Alpha shapes&lt;/h3&gt;
&lt;p&gt;Alpha shapes consist of a collection of lines drawn around a group of points. Probably the most familiar example of an α-shape is a convex hull, the smallest convex shape that can be drawn around a group of objects. For example, the following code draws a convex hull around some data from the iris dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(iris)
iris_sepals &amp;lt;- iris[,1:2]
# remove duplicate datapoints
iris_sepals &amp;lt;- iris_sepals[!duplicated(paste(iris_sepals$Sepal.Length, iris_sepals$Sepal.Width)), ]

# find points that lie on the convex hull
convexhull &amp;lt;- chull(iris_sepals)
# plot the data points
plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
hull_pts &amp;lt;- c(convexhull, convexhull[1])
# plot the convex hull
lines(iris_sepals[hull_pts, ], col = &amp;quot;magenta&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This convex hull (drawn in magenta) is an example of an α-shape: all convex hulls are α-shapes, but not all α-shapes are convex hulls. An α-shape doesn’t have to be convex – the lines making up the border of the shape can create concave edges relative to the points in the dataset. For example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# create a three-paneled figure
par(mfrow = c(1,3))

# create three different alpha shapes
alphashape_0.5 &amp;lt;- ashape(iris_sepals, alpha = 0.5)
alphashape_1 &amp;lt;- ashape(iris_sepals, alpha = 1)
alphashape_2 &amp;lt;- ashape(iris_sepals, alpha = 2)

# plot alpha = 0.5
plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
plot(alphashape_0.5, col = &amp;quot;magenta&amp;quot;, add = TRUE)
# plot alpha = 1
plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
plot(alphashape_1, col = &amp;quot;magenta&amp;quot;, add = TRUE)
# plot alpha = 2
plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
plot(alphashape_2, col = &amp;quot;magenta&amp;quot;, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# reset plotting parameters
par(mfrow = c(1,1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alpha shapes are created using the &lt;code&gt;ashape&lt;/code&gt; function from the &lt;code&gt;alphahull&lt;/code&gt; package. As you can see, increasing the α value makes the shape closer and closer to the convex hull, while low values of α make the shape more concave.&lt;/p&gt;
&lt;div id=&#34;alpha-shapes-to-polygons&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Alpha shapes to polygons&lt;/h4&gt;
&lt;p&gt;In order to use α-shapes with spatial data in R, I wanted to convert these shapes to polygons. To accomplish this, I modified some of the code from an &lt;a href=&#34;https://rpubs.com/geospacedman/alphasimple&#34;&gt;RPubs by Barry Rowlingson&lt;/a&gt; to create the following function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(igraph)
## 
## Attaching package: &amp;#39;igraph&amp;#39;
## The following objects are masked from &amp;#39;package:stats&amp;#39;:
## 
##     decompose, spectrum
## The following object is masked from &amp;#39;package:base&amp;#39;:
## 
##     union

ashape2poly &amp;lt;- function(ashape){
  # Convert node numbers into characters
  ashape$edges[,1] &amp;lt;- as.character(ashape$edges[,1])
  ashape_graph &amp;lt;- graph_from_edgelist(ashape$edges[,1:2], directed = FALSE)
  if (!is.connected(ashape_graph)) {
    stop(&amp;quot;Graph not connected&amp;quot;)
  }
  if (any(degree(ashape_graph) != 2)) {
    stop(&amp;quot;Graph not circular&amp;quot;)
  }
  if (clusters(ashape_graph)$no &amp;gt; 1) {
    stop(&amp;quot;Graph composed of more than one circle&amp;quot;)
  }
  # Delete one edge to create a chain
  cut_graph &amp;lt;- ashape_graph - E(ashape_graph)[1]
  # Find chain end points
  ends = names(which(degree(cut_graph) == 1))
  path = get.shortest.paths(cut_graph, ends[1], ends[2])$vpath[[1]]
  # this is an index into the points
  pathX = as.numeric(V(ashape_graph)[path]$name)
  # join the ends
  pathX = c(pathX, pathX[1])
  return(pathX)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the reasoning behind the function, check out the RPubs I referred to for guidance. For a sanity check, we can compare the resulting shape to the original α-shape we were trying to replicate:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alphapoly_1 &amp;lt;- ashape2poly(alphashape_1)
plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
# show the original alpha shape
plot(alphashape_1, lwd = 5, col = &amp;quot;gray&amp;quot;, add = TRUE)
# plot the new polygon
lines(iris_sepals[alphapoly_1, ], col = &amp;quot;magenta&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;alpha-hulls&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Alpha hulls&lt;/h3&gt;
&lt;p&gt;Alpha hulls add another layer of complexity to this process because they can include curved lines (arcs) as edges of a shape. For example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alphahull_1 &amp;lt;- ahull(iris_sepals, alpha = 1)

plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
plot(alphahull_1, col = &amp;quot;magenta&amp;quot;, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;arcs-to-lines&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Arcs to lines&lt;/h4&gt;
&lt;p&gt;To deal with this curvature, I wrote the following function to convert the arcs between points in the hull to a series of very short line segments in order to approximate the curve.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# function to convert an arc into line segments
# given the center of the arc, the radius, the vector, and the angle (radians)
arc2line &amp;lt;- function(center, r, vector, theta, npoints = 100) {
  # Get the angles at the extremes of the arcs
  angles &amp;lt;- anglesArc(vector, theta)
  # Generate sequence of angles along the arc to determine the points
  seqang &amp;lt;- seq(angles[1], angles[2], length = npoints)
  # Generate x coordinates for points along the arc
  x &amp;lt;- center[1] + r * cos(seqang)
  # Generate y coordinates for points along the arc
  y &amp;lt;- center[2] + r * sin(seqang)
  coords.xy &amp;lt;- cbind(x,y)
  line &amp;lt;- Line(coords = coords.xy)
  return(line)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;hulls-to-lines&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Hulls to lines&lt;/h4&gt;
&lt;p&gt;Using the previous function, I wrote another function to take an α-hull and convert it into a set of SpatialLines objects. The function uses the &lt;code&gt;arc2line&lt;/code&gt; function from above to convert each arc in the α-hull into a series of lines, before adding each of these sets of lines together.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ahull2lines &amp;lt;- function(hull){
  arclist &amp;lt;- hull$arcs
  lines &amp;lt;- list()
  for (i in 1:nrow(arclist)) {
    # Extract the attributes of arc i
    center_i &amp;lt;- arclist[i, 1:2]
    radius_i &amp;lt;- arclist[i, 3]
    vector_i &amp;lt;- arclist[i, 4:5]
    theta_i &amp;lt;- arclist[i, 6]
    # Convert arc i into a Line object
    line_i &amp;lt;- arc2line(center = center_i, r = radius_i, vector = vector_i, theta = theta_i)
    list_length &amp;lt;- length(lines)
    if(list_length &amp;gt; 0){
      # If a line has already been added to the list of lines
      # Define last_line_coords as the coordinates of the last line added to the list before the ith line
      last_line_coords &amp;lt;- lines[[list_length]]@coords
    }
    if(i == 1){
      # Add the first line to the list of lines
      lines[[i]] &amp;lt;- line_i
    } else if(all.equal(line_i@coords[1,], last_line_coords[nrow(last_line_coords),])){
      # If the first coordinate in the ith line is equal to the last coordinate in the previous line
      # then those lines should be connected
      # Row bind the coordinates for the ith line to the coordinates of the previous line in the list
      lines[[list_length]]@coords &amp;lt;- rbind(last_line_coords, line_i@coords[2:nrow(line_i@coords),])
    } else {
      # If the first coordinate in the ith line does not match the last coordinate in the previous line
      # then the ith line represents a new line
      # Add the ith line to the list as a new element
      lines[[length(lines) + 1]] &amp;lt;- line_i
    }
  }
  # Convert the list of lines to a Line object
  lines &amp;lt;- Lines(lines, ID = &amp;#39;l&amp;#39;)
  # Convert the Line object to a SpatialLines object
  sp_lines &amp;lt;- SpatialLines(list(lines))
  return(sp_lines)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results look like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lines_1 &amp;lt;- ahull2lines(alphahull_1)
# the result is a SpatialLines object
class(lines_1)
## [1] &amp;quot;SpatialLines&amp;quot;
## attr(,&amp;quot;package&amp;quot;)
## [1] &amp;quot;sp&amp;quot;

plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
# show the original alpha shape
plot(alphahull_1, lwd = 5, col = &amp;quot;gray&amp;quot;, add = TRUE)
# plot the new polygon
plot(lines_1, col = &amp;quot;magenta&amp;quot;, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The resulting SpatialLines object is an almost spot-on approximation of the original α-hull (shown in gray).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;spatiallines-to-spatialpolygon&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;SpatialLines to SpatialPolygon&lt;/h4&gt;
&lt;p&gt;Now, I needed a way to convert the SpatialLines object into a SpatialPolygon that would cover the same shape as the original α-hull. To accomplish this, I wrote a function that takes a SpatialLines object, checks which lines are part of polygons (i.e. form closed shapes), and converts those polygons to a SpatialPolygon.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spLines2poly &amp;lt;- function(sp_lines){
  # Extract the lines slot
  lines_slot &amp;lt;- sp_lines@lines[[1]]
  # Create a list of booleans indicating whether a given Line represents a polygon
  poly_bool &amp;lt;- sapply(lines_slot@Lines, function(x){
    coords &amp;lt;- lines_slot@Lines[[1]]@coords
    # Check if the first coordinate in the line is the same as the last
    all.equal(coords[1,], coords[nrow(coords),])
  })
  # Pull out the lines that form polygons
  poly_lines &amp;lt;- sp_lines[poly_bool]
  poly_lines_slot &amp;lt;- poly_lines@lines
  # Create SpatialPolygons
  sp_polys &amp;lt;- SpatialPolygons(list(Polygons(lapply(poly_lines_slot, function(x) {
    Polygon(slot(slot(x, &amp;quot;Lines&amp;quot;)[[1]], &amp;quot;coords&amp;quot;))
  }), ID = &amp;quot;1&amp;quot;)))
  return(sp_polys)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can apply this function to the &lt;code&gt;lines_1&lt;/code&gt; object we made from the original &lt;code&gt;alphahull_1&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SpPoly_1 &amp;lt;- spLines2poly(lines_1)
class(SpPoly_1)
## [1] &amp;quot;SpatialPolygons&amp;quot;
## attr(,&amp;quot;package&amp;quot;)
## [1] &amp;quot;sp&amp;quot;

plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
# show the original alpha shape
plot(alphahull_1, lwd = 5, col = &amp;quot;gray&amp;quot;, add = TRUE)
# plot the new polygon
plot(SpPoly_1, border = &amp;quot;magenta&amp;quot;, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;alpha-hulls-to-spatialpolygons&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Alpha hulls to SpatialPolygons&lt;/h4&gt;
&lt;p&gt;Finally, we can string all of those functions together to create a single function that will convert an α-hull directly into a SpatialPolygon:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ahull2poly &amp;lt;- function(hull){
  # Convert the alpha hull to SpatialLines
  hull2SpatialLines &amp;lt;- ahull2lines(hull)
  # Convert SpatialLines to SpatialPolygon
  SpatialLines2SpatialPolygon &amp;lt;- spLines2poly(hull2SpatialLines)
  return(SpatialLines2SpatialPolygon)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a final sanity check, we can see that the resulting shape is the same as the original shape produced by the &lt;code&gt;alphahull&lt;/code&gt; package:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hullpoly_1 &amp;lt;- ahull2poly(alphahull_1)
class(hullpoly_1)
## [1] &amp;quot;SpatialPolygons&amp;quot;
## attr(,&amp;quot;package&amp;quot;)
## [1] &amp;quot;sp&amp;quot;

plot(iris_sepals, pch = 19, col = &amp;quot;darkseagreen&amp;quot;)
# show the original alpha shape
plot(alphahull_1, lwd = 5, col = &amp;quot;gray&amp;quot;, add = TRUE)
# plot the new polygon
plot(hullpoly_1, border = &amp;quot;magenta&amp;quot;, add = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-03-18-alpha-hull_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;github&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;GitHub&lt;/h2&gt;
&lt;p&gt;The code for these functions is on my GitHub at &lt;a href=&#34;https://github.com/babichmorrowc/hull2spatial&#34; class=&#34;uri&#34;&gt;https://github.com/babichmorrowc/hull2spatial&lt;/a&gt;. If you have any thoughts or suggestions, please comment on this post or submit a pull request on GitHub. I hope to be formulating these functions into a package in the near future, so stay tuned!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;citations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Citations&lt;/h2&gt;
&lt;p&gt;Beatriz Pateiro-Lopez and Alberto Rodriguez-Casal. (2016). alphahull: Generalization of the Convex Hull of a Sample of Points in the Plane. R package version 2.1. &lt;a href=&#34;https://CRAN.R-project.org/package=alphahull&#34; class=&#34;uri&#34;&gt;https://CRAN.R-project.org/package=alphahull&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Talk: Using SVMs to model ranges of congeneric sloth species</title>
      <link>/talk/nysdm_march2019/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 -0400</pubDate>
      
      <guid>/talk/nysdm_march2019/</guid>
      <description>&lt;p&gt;&lt;iframe src=&#34;https://docs.google.com/presentation/d/e/2PACX-1vS_w666eIt4-3dUI-z6iVlD08EphadvhGys2IarVUPk7QIdG3dn7opO1LLLeuM7vcb6j8k7_5nVOAef/embed?start=false&amp;loop=false&amp;delayms=5000&#34; frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Talk: STEM careers in museums</title>
      <link>/talk/la_lgbt_careertalk_2019/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 -0500</pubDate>
      
      <guid>/talk/la_lgbt_careertalk_2019/</guid>
      <description>&lt;p&gt;&lt;iframe src=&#34;https://docs.google.com/presentation/d/e/2PACX-1vT-sB5lS2bKsitOCUenYo1xA3pMzCxfo37TAnB408noR6SJPJpePBfei6p6FMylQFdmJ-FI4z-himQc/embed?start=false&amp;loop=false&amp;delayms=5000&#34; frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hacking Meteorites Part 1: Calculating percent weights</title>
      <link>/post/2019-02-20-meteoritecluster1/</link>
      <pubDate>Wed, 20 Feb 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-02-20-meteoritecluster1/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/obj1_8bt_Fe.png&#34; /&gt;
&lt;figcaption&gt;
Intensity of iron in a meteorite.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Earlier this month I participated in the American Museum of Natural History’s annual hackathon (see my last &lt;a href=&#34;https://babichmorrowc.github.io/post/2019-02-14-hackathon/&#34;&gt;post&lt;/a&gt; for details about the event overall). During the hackathon, I worked with Katy Abbott, another Helen Fellow at the museum with me, to use a machine learning algorithm called DBSCAN to tackle our challenge. This post explains the process we used to complete the first step of the challenge: estimating the percent weights of elements in a meteorite.&lt;/p&gt;
&lt;div id=&#34;challenge-accepted&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Challenge accepted&lt;/h2&gt;
&lt;p&gt;Our team, consisting of Peter Kang, Jackson Lee, Jeremy Neiman, John Underwood, Katy Abbott, Meret Götschel, and myself, chose to work on the &lt;a href=&#34;https://github.com/amnh/HackTheSolarSystem/wiki/Meteorite-Mineral-Mapping&#34;&gt;Meteorite Mineral Mapping challenge&lt;/a&gt;. For this challenge, our museum stakeholders, Marina Gemma and Sam Alpert, wanted a way to identify the mineral composition of meteorites.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pixels-to-percents&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pixels to percents&lt;/h2&gt;
&lt;p&gt;The scientists scan meteorites with an electron microprobe, a device that provides the intensity of x-rays emitted from certain elements. The electron microprobe results in images with grayscale intensities corresponding to these x-ray intensities on a pixel-by-pixel basis.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/meteorite_pixel_intensity.png&#34; /&gt;
&lt;figcaption&gt;
Images of a meteorite produced by the electron microprobe showing pixel intensities for each of 10 elements - brighter grayscale values indicate greater amounts of that element in a pixel.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Our first step was to convert these pixel intensities to the percent weight of each element in the mineral at that pixel. To do that, we referred to a set of standard images taken of minerals with a known proportion of each element. For example, the image below shows the pixel intensities of iron in 8 minerals: you can see that the pixels are brightest in Fe, or pure iron, and lower in iron oxide (&lt;span class=&#34;math inline&#34;&gt;\(\text{Fe}_3\text{O}_4\)&lt;/span&gt;) and troilite, or iron sulfide (FeS).&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/iron_standard.png&#34; /&gt;
&lt;figcaption&gt;
Standard scan of the intensity of iron in each of 8 known minerals.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;We can relate the intensity of the iron pixels in the Fe mineral, for example, to the percent weight in that mineral (100%, since iron is the only element in Fe).&lt;/p&gt;
&lt;div id=&#34;import-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Import data&lt;/h3&gt;
&lt;p&gt;We started by creating a .csv file with the percent weight of each element in the minderals from the standards:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# import libraries
from sklearn.cluster import DBSCAN as dbscan
from sklearn.linear_model import LinearRegression
import pandas as pd
import numpy as np
from sklearn import metrics
import matplotlib.pyplot as plt
import matplotlib.colors
from sklearn.decomposition import PCA
from pathlib import Path
from skimage.io import imread, imshow
import numpy.ma as ma
from collections import Counter
# read in percent weights by element of the minerals in the standard
weights = pd.read_csv(&amp;quot;/Users/hellenfellows/Desktop/website-hugo/static/mineralmapping/weights_to_minerals.csv&amp;quot;)
print(weights.head())
##        mineral  Mg     Ni  Al        Fe      Ca  Cr   P        S      Ti  Si
## 0  CaTiO3std15 NaN    NaN NaN       NaN  29.481 NaN NaN      NaN  35.211 NaN
## 1  Fe-num2std9 NaN    NaN NaN  100.0000     NaN NaN NaN      NaN     NaN NaN
## 2      FeSstd2 NaN    NaN NaN   63.5252     NaN NaN NaN  36.4748     NaN NaN
## 3   Fe3O4std15 NaN    NaN NaN   72.3591     NaN NaN NaN      NaN     NaN NaN
## 4       Nistd9 NaN  100.0 NaN       NaN     NaN NaN NaN      NaN     NaN NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note: I was able to add the above Python chunk in R by following &lt;a href=&#34;https://babichmorrowc.github.io/post/2019-02-20-pythonrmd/&#34;&gt;these instructions&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There is a linear relationship between pixel intensity and percent weight, so we used linear regression to find the slope of this relationship. We read in the .csv of pixel intensities for each element in the standards:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# read in the pixel intensities by element in the standard
mineral_standards = pd.read_csv(&amp;#39;/Users/hellenfellows/Desktop/website-hugo/static/mineralmapping/mineral_standards.csv&amp;#39;)
print(mineral_standards.head())
##    Mg  Ni  Al  Fe   Ca  Cr  P  S   Ti  Si      mineral
## 0   0   0   0   0  171   0  4  0  459   0  CaTiO3std15
## 1   0   0   0   0  148   3  2  0  462   1  CaTiO3std15
## 2   0   2   0   0  141   6  3  0  455   2  CaTiO3std15
## 3   1   2   2   0  122   6  3  0  502   0  CaTiO3std15
## 4   0   0   0   0  138   5  5  0  457   1  CaTiO3std15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We modified the chemical formulas of each mineral using a dictionary by separating each element in the mineral with an “_&amp;quot; to make looping easier.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# create dictionary to standardize file names to chemical formulas
# needed to separate each element in the formula with an _ to make looping easier
mineral_dict = dict(zip(np.unique(mineral_standards[&amp;#39;mineral&amp;#39;]),
    [&amp;quot;Ca_Ti_O_3&amp;quot;, &amp;quot;Fe_&amp;quot;, &amp;quot;Fe_3O_4&amp;quot;, &amp;quot;Fe_S_&amp;quot;, &amp;quot;Ni_S_&amp;quot;, &amp;quot;Ni_&amp;quot;, &amp;quot;Ca_Fe_Mg_Mn_Ni_Si_&amp;quot;, &amp;quot;Ti_O_2&amp;quot;]))
# use dictionary to change mineral columns to underscore format
weights[&amp;#39;mineral&amp;#39;] = weights[&amp;#39;mineral&amp;#39;].map(mineral_dict)
mineral_standards[&amp;#39;mineral&amp;#39;] = mineral_standards[&amp;#39;mineral&amp;#39;].map(mineral_dict)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we created a list of the elements accounted for in the standards and made an empty dataframe called &lt;code&gt;coefs&lt;/code&gt; to fill with the coefficients of the relationship between pixel intensity and percent weight for each element:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# list of elements
# need to ignore the &amp;quot;mineral&amp;quot; column of the data
elements = [val for val in mineral_standards.columns if val != &amp;#39;mineral&amp;#39;]
coefs = pd.DataFrame(index = [&amp;#39;coeff&amp;#39;], columns = elements)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;linear-regressions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Linear regressions&lt;/h3&gt;
&lt;p&gt;Now we looped through the elements to create linear regressions of percent weight vs. pixel intensity based on the intensities in the standards. For these regressions, we forced the intercept to be zero because zero pixel intensity should imply zero percent weight.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# make a linear regression forcing the intercept to be zero
# since zero intensity should correspond to zero percent weight
lr = LinearRegression(fit_intercept = False)
# loop through elements to create linear regression of percent weight vs pixel intensity
# in the minerals in the standard
for element in elements:
    element_df = mineral_standards[mineral_standards[&amp;#39;mineral&amp;#39;].str.contains(element + &amp;quot;_&amp;quot;)]
    # if the element has no percent weights, skip it
    if element_df.empty:
        continue
    minerals = element_df[&amp;#39;mineral&amp;#39;].unique()
    xis = np.empty(0)
    yis = np.empty(0)
    for mine in minerals:
        # get percent weights of the element in that mineral
        weight = weights[weights[&amp;#39;mineral&amp;#39;] == mine][element]
        intensities = element_df[element_df[&amp;#39;mineral&amp;#39;] == mine][element]
        xis = np.append(xis, np.array(intensities))
        yis = np.append(yis, np.repeat(weight, len(intensities)))
    xis, yis = xis.reshape(-1,1), yis.reshape(-1,1)
    # fit linear regression on percent weight vs intensity
    reg = lr.fit(xis,yis)
    xi_pred =  np.arange(0,900).reshape(-1,1)
    # create predictions for range of intensity values
    pred = reg.predict(xi_pred)
    reg.coef_
    # get the linear regression coefficient for each element
    coefs[element] = float(reg.coef_)
# print the coefficients for each element
print(coefs)
##              Mg        Ni   Al    ...            S        Ti        Si
## coeff  0.118599  0.328796  NaN    ...     0.469225  0.077627  0.097906
## 
## [1 rows x 10 columns]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus &lt;code&gt;coefs&lt;/code&gt; contains the coeficient relating pixel intensity of an element to its percent weight in the mineral: for example, the percent weight of Mg in an mineral is equal to 0.118599 times its pixel intensity.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/mineral_regression.png&#34; /&gt;
&lt;figcaption&gt;
X-axes are pixel intensity and y-axes are percent weight of the element. Blue points indicate the pixel intensities of the element for a given percent weight based on a mineral in the standard. Orange points indicate the linear regression calculated above.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-percent-weights&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate percent weights&lt;/h3&gt;
&lt;p&gt;Finally, we used these coefficients to calculate the predicted percent weights of each element in the two meteorites we were analyzing on a pixel-by-pixel basis. The code for this portion of the analysis is available in the latter end of &lt;a href=&#34;https://github.com/HackTheSolarSystem/MineralMapping/blob/master/backend/mineral_mapping_script.py&#34;&gt;this script&lt;/a&gt;. Note that for any pixel where the percent weight of an element was predicted to be higher than 100%, we set the percent weight to 100%. From these calculations, we ended up with the following files:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# read file of predicted percent weights for meteorite 1
df_obj1 = pd.read_csv(&amp;#39;/Users/hellenfellows/Desktop/website-hugo/static/mineralmapping/predicted_percentweight_obj1.csv&amp;#39;)
df_obj1 = df_obj1.fillna(0)
df_obj1.drop(&amp;#39;Unnamed: 0&amp;#39;, axis = 1, inplace = True)
print(df_obj1.head())
# read file of predicted percent weights for meteorite 2
##          Ca        Ti   Al   Cr    ...       P         Fe        Ni        Mg
## 0  8.595462  0.698642  0.0  0.0    ...     0.0  51.212925  0.986388  5.692734
## 1  4.512618  0.543388  0.0  0.0    ...     0.0  53.453490  1.972775  2.846367
## 2  2.578639  0.465761  0.0  0.0    ...     0.0  63.696075  3.287959  1.067388
## 3  2.148866  0.310508  0.0  0.0    ...     0.0  57.934621  3.945550  0.237197
## 4  1.719092  0.543388  0.0  0.0    ...     0.0  58.254702  3.616755  0.118599
## 
## [5 rows x 10 columns]
df_obj2 = pd.read_csv(&amp;#39;/Users/hellenfellows/Desktop/website-hugo/static/mineralmapping/predicted_percentweight_obj2.csv&amp;#39;)
df_obj2 = df_obj2.fillna(0)
df_obj2.drop(&amp;#39;Unnamed: 0&amp;#39;, axis = 1, inplace = True)
print(df_obj2.head())
##           Si    P   Cr   Al    ...            Ca        Mg        Ni         Fe
## 0  22.322556  0.0  0.0  0.0    ...      0.429773  1.304585  4.931938  14.403635
## 1  11.650808  0.0  0.0  0.0    ...      0.000000  0.355796  2.630367  43.530986
## 2   4.601580  0.0  0.0  0.0    ...      0.429773  0.000000  1.643979  54.093652
## 3   2.349743  0.0  0.0  0.0    ...      0.000000  0.000000  0.986388  57.294460
## 4   0.783248  0.0  0.0  0.0    ...      0.000000  0.000000  1.315183  48.972359
## 
## [5 rows x 10 columns]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each row in these .csv files corresponds to a pixel in the original image. Each value gives the predicted percent weight of a given element in that pixel.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;up-next&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Up next&lt;/h2&gt;
&lt;p&gt;Now that we had converted pixel intensities to predicted percent weights, we were ready to use our clustering algorithm to identify potential minerals in the meteorite. Stay tuned for a future post showing how we used DBSCAN to accomplish this!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;further-reading&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;p&gt;Jeremy Neiman, one of my team members, wrote an excellent &lt;a href=&#34;https://towardsdatascience.com/machine-learning-meteorites-fcd8f6859ed7&#34;&gt;post&lt;/a&gt; describing the challenge in further detail, so check that out for more information.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Python in RMarkdown</title>
      <link>/post/2019-02-20-pythonrmd/</link>
      <pubDate>Wed, 20 Feb 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-02-20-pythonrmd/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/reticulate.png&#34; /&gt;
&lt;figcaption&gt;
The &lt;code&gt;reticulate&lt;/code&gt; package logo. &lt;/figcatption&gt;
&lt;/figure&gt;
&lt;div id=&#34;using-python-in-rmarkdown&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using Python in RMarkdown&lt;/h2&gt;
&lt;p&gt;In order to write blog posts using Python code, I wanted to figure out a way to include Python code chunks in RMarkdowns. When you insert a code chunk in RMarkdown, you have the option of specifying the language of that chunk: the default is R, but you can also insert a Bash, SQL, Python, etc. code chunk.&lt;/p&gt;
&lt;p&gt;When I attempted to insert a Python code chunk and import libraries, however, I kept getting the error:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error in py_run_string_impl(code, local, convert) :&lt;/code&gt; &lt;code&gt;ImportError: No module named sklearn.cluster&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;From running Python in Atom, I knew I had the &lt;code&gt;sklearn.cluster&lt;/code&gt; module installed, so the problem must be in the connection between R and Python.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reticulate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;reticulate&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;reticulate&lt;/code&gt; package in R (website &lt;a href=&#34;https://rstudio.github.io/reticulate/index.html&#34;&gt;here&lt;/a&gt; allows R to interact with Python. I installed the package from RStudio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install.packages(&amp;quot;reticulate&amp;quot;)
library(reticulate)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;changing-python-versions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Changing Python versions&lt;/h2&gt;
&lt;p&gt;Installing &lt;code&gt;reticulate&lt;/code&gt; still didn’t allow me to knit the RMarkdown with a Python code chunk, however. I followed the instructions in &lt;a href=&#34;https://rstudio-pubs-static.s3.amazonaws.com/397064_bd288708515c4b71a6e78dfe91b8bb99.html&#34;&gt;this post&lt;/a&gt; by Pablo Franco to check the Python version that &lt;code&gt;reticulate&lt;/code&gt; was using:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;py_discover_config()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ended up with the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python:         /usr/bin/python
libpython:      /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config/libpython2.7.dylib
pythonhome:     /System/Library/Frameworks/Python.framework/Versions/2.7:/System/Library/Frameworks/Python.framework/Versions/2.7
version:        2.7.10 (default, Aug 17 2018, 19:45:58)  [GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.0.42)]
numpy:          /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy
numpy_version:  1.8.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I wanted to be running Python version 3.6, which was the version I had installed using Anaconda, so I needed to change the path.&lt;/p&gt;
&lt;div id=&#34;set-up-chunk&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Set-up chunk&lt;/h3&gt;
&lt;p&gt;I discovered that you can set the path to a different installation of Python by modifying the setup chunk at the start of the RMarkdown. According to the &lt;a href=&#34;https://bookdown.org/yihui/rmarkdown/language-engines.html&#34;&gt;&lt;code&gt;bookdown&lt;/code&gt; website&lt;/a&gt;, the default used is Python 2.&lt;/p&gt;
&lt;p&gt;My default version of this set-up chunk looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can set the chunk option &lt;code&gt;engine.path&lt;/code&gt; to specify the path to the engine interpreter and change it from the default Python 2.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;finding-python-path&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Finding Python path&lt;/h3&gt;
&lt;p&gt;I now needed to find the actual path to Python that I wanted to use. I did this by opening up Python separately from RStudio (I used Atom for this) and running the following (I got the code for this from &lt;a href=&#34;https://www.dummies.com/programming/python/how-to-find-path-information-in-python/&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import sys
for p in sys.path:
    print(p)
## /anaconda3/bin
## /anaconda3/lib/python36.zip
## /anaconda3/lib/python3.6
## /anaconda3/lib/python3.6/lib-dynload
## /anaconda3/lib/python3.6/site-packages
## /anaconda3/lib/python3.6/site-packages/aeosa
## /Library/Frameworks/R.framework/Versions/3.5/Resources/library/reticulate/python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this information, I could tell I wanted to use the path &lt;code&gt;/anaconda3/lib/python3.6&lt;/code&gt;, rather than &lt;code&gt;/usr/bin/python&lt;/code&gt;, which is what RMarkdown had originally been using. I modified by set-up chunk to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, engine.path = list(python = &amp;#39;/anaconda3/bin/python3.6&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;other-options&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other options&lt;/h2&gt;
&lt;p&gt;This solution enabled me to knit RMarkdowns with Python code chunks! It changes the engine interpreter globally, which you could do for multiple engines simultaneously, like Python and Ruby, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;knitr::opts_chunk$set(engine.path = list(
  python = &amp;#39;/anaconda3/bin/python3.6&amp;#39;,
  ruby = &amp;#39;/usr/local/bin/ruby&amp;#39;
))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can specify the engine interpreter locally in each code chunk by starting the chunk with &lt;code&gt;{python, engine.path = &#39;/anaconda3/bin/python3.6&lt;/code&gt;}, for example.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>#HackTheSolarSystem</title>
      <link>/post/2019-02-14-hackathon/</link>
      <pubDate>Thu, 14 Feb 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-02-14-hackathon/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:40%&#34; src=&#34;/img/hackthesolarsystem.png&#34; /&gt;
&lt;/figure&gt;
&lt;p&gt;Last weekend I had the opportunity to participate in my first ever hackathon: the #HackTheSolarSystem hackathon hosted by the American Museum of Natural History.&lt;/p&gt;
&lt;div id=&#34;what-is-a-hackathon-anyways&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What is a hackathon, anyways?&lt;/h2&gt;
&lt;p&gt;This is a question I got asked countless times this last week as I informed my friends and family that I would be at work &lt;strong&gt;all&lt;/strong&gt; weekend (yes, including Friday night, yes, including Saturday night, no, I will not be able to socialize at all). And, in fairness, this is a question I wouldn’t have had an answer to prior to this job. A hackathon is an event where participants come together to use technology to address a challenge. Usually, the event takes place over a few days, where hackers form teams and collaborate on their projects, before presenting their solutions.&lt;/p&gt;
&lt;p&gt;When I learned about this concept, I was baffled by the idea that it would be possible to come up with any kind of viable solution to a problem in only 24 hours. Coming from an academic background, I’m used to months of reading papers to get oriented to a problem before I can produce any kind of meaningful code. This event forced us to dive right in, looking at the problem from a computer science standpoint, rather than striving to get the full scientific background on the problem. I was amazed by the ability of all the teams at the event to create meaningful solutions to scientific problems they had not necessarily studied before.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-ammh-hackathon&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The AMMH Hackathon&lt;/h2&gt;
&lt;p&gt;For the past five years, the American Museum of Natural History has hosted a hackathon. #HackTheSolarSystem is the first and only hackathon I have participated in thus far, so I can’t compare it to other events, but my understanding is that the museum seeks to put on a slightly different type of event than other hackathons: AMNH wants to give technologists and scientists the opportunity to work together to create solutions to real research problems. For #HackTheSolarSystem, museum scientists from the Department of Earth and Planetary Science put forth a series of challenges they face in their research that they thought could be solved through technology. These challenges ranged from tracking dust particles through aerogel to visualizing the Sun (a full list of challenges is available &lt;a href=&#34;https://github.com/amnh/HackTheSolarSystem/wiki/Challenges&#34;&gt;here&lt;/a&gt;). In addition to the scientific challenges, there were also educational challenges for both high school students and educators.&lt;/p&gt;
&lt;p&gt;On Friday night, the museum “stakeholders”, i.e. the scientists posing the challenges, presented their challenges and led participants on tours of various areas of the museum, like the Hall of Meteorites and the Earth and Planetary Sciences department. Then, from Saturday at 2:00 pm to Sunday at 1:00 pm, us hackers stayed at the museum to develop solutions to our chosen challenges. Most hackers worked on teams formed at the event, although some corporate teams came into the hackathon with a team already formed.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-challenge&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Challenge&lt;/h2&gt;
&lt;p&gt;I chose to work on the meteorite mineral mapping challenge: our “stakeholders”, museum scientists Marina Gemma and Sam Alpert, wanted a way to identify mineral composition in images of meteorites. Each meteorite slice had been imaged, resulting in data consisting of pixel intensity for a handful of elements. We also had access to a series of standards with known mineral content so we could compare the pixel intensities in these known minerals with the pixel intensities in the unknown minerals.&lt;/p&gt;
&lt;p&gt;Our team (pictured below) used four different approaches to address this problem: linear classification via SVM, random forest classification, nearest neighbor classification, and cluster inference. You can check out more details on these solutions in the Readme of our GitHub repository: &lt;a href=&#34;https://github.com/HackTheSolarSystem/MineralMapping&#34; class=&#34;uri&#34;&gt;https://github.com/HackTheSolarSystem/MineralMapping&lt;/a&gt;. (And I will post a more detailed explanation of the clustering solution in a later post, which is the part of the code I focused on!)&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/hackathon_team.jpg&#34; /&gt;
&lt;figcaption&gt;
From left to right: Peter Kang, Jackson Lee, Jeremy Neiman, John Underwood, Katy Abbott, Cecina Babich Morrow, Meret Götschel
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Our solution ended up making us one of the four primary winning teams at the hackathon! We won the “LabCoat Knockout” award for creating a solution with the potential to change the nature of research. We plan to continue working with our museum stakeholders to fine-tune our code so that it can be used in their research in the future. To me, that is the most exciting part of this event - that a group of technologists from diverse backgrounds (none of which knew much about meteorites before this event!) could write code in 24 hours with the potential to solve a scientific problem with a concrete impact on research at the museum.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Grafting phylogenies</title>
      <link>/post/2019-01-09-grafting-trees/</link>
      <pubDate>Fri, 18 Jan 2019 21:13:14 -0500</pubDate>
      
      <guid>/post/2019-01-09-grafting-trees/</guid>
      <description>


&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;/img/bodymass_tetrapod_tree.png&#34; /&gt;
&lt;/figure&gt;
&lt;div id=&#34;inspiration-for-this-post&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Inspiration for this post&lt;/h1&gt;
&lt;p&gt;This post comes from the finishing touches I needed to put on a paper about &lt;a href=&#34;https://babichmorrowc.github.io/project/life_history/&#34;&gt;life history evolution&lt;/a&gt;. The paper compares life history traits across the four groups of tetrapods (amphibians, reptiles, mammals, and birds), so when I carried out the nitty gritty phylogenetic analyses, I used four separate phylogenies. When it came time to make a figure to visualize those analyses, however, I ended up with an unwieldy (and unpublishable) 16-panel figure (four phylogenies by four traits). One of my coauthors suggested using a tetrapod supertree to visualize the evolution of the traits across all four classes simultaneously.&lt;/p&gt;
&lt;div id=&#34;uyeda-et-al.-2017&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Uyeda et al. 2017&lt;/h2&gt;
&lt;p&gt;Uyeda et al. did something similar in their 2017 paper &lt;a href=&#34;https://www.journals.uchicago.edu/doi/10.1086/692326&#34;&gt;The evolution of energetic scaling across the vertebrate tree of life&lt;/a&gt;. They stitched together fish, amphibian, squamate, bird, and mammal phylogenies together to visualize metabolic rate across all vertebrates:&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:75%&#34; src=&#34;/img/uyeda_figure.png&#34; /&gt;
&lt;figcaption&gt;
Figure 1 from Uyeda et al. 2017
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;At first, I was very hopeful that I would be able to download this supertree and prune it to the taxa in my analysis since the authors were using the same clade specific phylogenies that I was. The phylogeny is available on Data Dryad (&lt;a href=&#34;https://datadryad.org/resource/doi:10.5061/dryad.3c6d2&#34; class=&#34;uri&#34;&gt;https://datadryad.org/resource/doi:10.5061/dryad.3c6d2&lt;/a&gt;). Unfortunately, after downloading that phylogeny and pruning it to include species I used in my analysis, I ended up with approximately 15% of the species I analyzed in the resulting tree.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;into-the-code&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Into the code&lt;/h1&gt;
&lt;p&gt;Since my easy solution didn’t pan out and I couldn’t get enough information from the supplemental material for the paper to replicate their analyses, I looked on GitHub to try to find Uyeda’s code. Hooray for GitHub once again, because the repository for the paper can be found here: &lt;a href=&#34;https://github.com/uyedaj/bmr&#34; class=&#34;uri&#34;&gt;https://github.com/uyedaj/bmr&lt;/a&gt;. The &lt;a href=&#34;https://github.com/uyedaj/bmr/blob/master/R/ManuscriptNotebook.Rmd&#34;&gt;RMarkdown&lt;/a&gt; details the analyses for the paper, including the process for making the full tree.&lt;/p&gt;
&lt;p&gt;Start with loading the necessary packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(phytools)
## Loading required package: ape
## Warning: package &amp;#39;ape&amp;#39; was built under R version 3.5.2
## Loading required package: maps
library(geiger)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;the-original-phylogenies&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The original phylogenies&lt;/h2&gt;
&lt;p&gt;I was working with four separate phylogenies: amphibians, squamates, birds, and mammals. For amphibians, I used a congruified time-tree from the &lt;code&gt;PhyloOrchard&lt;/code&gt; package (O’Meara et al. 2013) that was constructed using the Alfaro et al. timetree of gnathostomes (Alfaro et al. 2009) as the reference and the Pyron and Wiens amphibian phylogeny as the target (Pyron and Wiens 2011).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(amphibiantree$tip.label)
## [1] 2871
plot(amphibiantree, type = &amp;quot;fan&amp;quot;, show.tip.label = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For squamates, I used the Zheng and Wiens time-calibrated phylogeny (Zheng and Wiens 2016).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(squamatetree$tip.label)
## [1] 378
plot(squamatetree, type = &amp;quot;fan&amp;quot;, show.tip.label = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For birds, I used the Jetz phylogeny (Jetz et al. 2012).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(birdtree$tip.label)
## [1] 9993
plot(birdtree, type = &amp;quot;fan&amp;quot;, show.tip.label = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For mammals, I used the supertree from Fritz et al. 2009.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(mammaltree$tip.label)
## [1] 5020
plot(mammaltree, type = &amp;quot;fan&amp;quot;, show.tip.label = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reading-in-trees&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reading in trees&lt;/h2&gt;
&lt;p&gt;The first step of the process is reading in the individual phylogenies you want to stitch together. This step is straightforward, with one exception: you cannot have species that are present in multiple of the individual trees. For example, my squamate phylogeny included &lt;em&gt;Gallus gallus&lt;/em&gt; (red junglefowl) and &lt;em&gt;Dromaius novaehollandia&lt;/em&gt; (emu). Since these species were also present in my bird phylogeny, I got the following error: &lt;code&gt;Found matching tips in &#39;subtree&#39; and &#39;phy&#39;&lt;/code&gt;. To solve this problem, I just removed these tips from the squamate tree:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;squamatetree &amp;lt;- drop.tip(phy = squamatetree, tip = c(&amp;quot;Gallus_gallus&amp;quot;, &amp;quot;Dromaius_novaehollandiae&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ended up with the following list of trees and corresponding tip labels:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tree_list &amp;lt;- list(amphib=amphibiantree, birds=birdtree, squam=squamatetree, mamm=mammaltree)
class(tree_list) &amp;lt;- &amp;quot;multiPhylo&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;make-a-tree-with-orders&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Make a tree with orders&lt;/h2&gt;
&lt;p&gt;In Uyeda et al. (2017), the authors were creating a phylogeny for all vertebrates, but for my analyses I was only examining tetrapods, so I didn’t have a fish phylogeny to include. The original code from Uyeda et al. to create a tree with the 5 vertebrate orders looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tip.labels &amp;lt;- c(&amp;quot;fish&amp;quot;, &amp;quot;amphib&amp;quot;, &amp;quot;squam&amp;quot;, &amp;quot;birds&amp;quot;, &amp;quot;mamm&amp;quot;)

## Make a tree with just orders:
edge &amp;lt;- matrix(c(9, 4,
  9, 3,
  8, 5,
  8, 9,
  7, 8,
  7, 2,
  6, 7,
  6, 1), byrow=TRUE, ncol=2)
## Dates from Timetree of life (timetree.org)
edge.length &amp;lt;- c(274.9, 274.9, 324.5, 324.5-274.9, 382.9-324.5, 382.9, 454.6-382.9 , 454.6)
Nnode &amp;lt;- 4
ordertree &amp;lt;- list(edge=edge, Nnode=Nnode, tip.label=tip.labels, edge.length=edge.length)
class(ordertree) &amp;lt;- &amp;#39;phylo&amp;#39;
plot(ordertree)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;To visualize the results, we can add tip labels, node labels, and edge labels to the tree with the branch lengths:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(ordertree)
tiplabels()
nodelabels()
edgelabels(ordertree$edge.length, bg=&amp;quot;black&amp;quot;, col=&amp;quot;white&amp;quot;, font=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;getting-rid-of-fish&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Getting rid of fish&lt;/h3&gt;
&lt;p&gt;Since I didn’t have fish, I needed to make a few modifications. First, &lt;code&gt;tip.labels&lt;/code&gt; didn’t need “fish” in it anymore:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# remove &amp;quot;fish&amp;quot; from tip.labels:
tip.labels &amp;lt;- c(&amp;quot;amphib&amp;quot;, &amp;quot;squam&amp;quot;, &amp;quot;birds&amp;quot;, &amp;quot;mamm&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, for the trickier part - I needed to modify the edge matrix. The edge matrix contains the starting and ending nodes for each edge in a tree. As we can see from the plot above, numbering works in the following way: the tips are numbered starting at the top from 1 to the number of tips and the nodes are numbered starting at the root and moving towards the tips. To get rid of fish, I needed to delete one tip from the tree and one node (the original root node). I sketched out what I wanted the new order tree to look like, complete with numbered nodes and tips, and created the following edge matrix:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;edge &amp;lt;- matrix(c(7, 3,
  7, 2,
  6, 4,
  6, 7,
  5, 6,
  5, 1), byrow=TRUE, ncol=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since I was losing two edges from the phylogeny (the one going from the root to fish and the one from the root to the last common ancestor of tetrapods), I also needed to modify the edge lengths by removing 454.6-382.9 and 454.6:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;edge.length &amp;lt;- c(274.9, 274.9, 324.5, 324.5-274.9, 382.9-324.5, 382.9)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final modification I needed was to decrease &lt;code&gt;Nnode&lt;/code&gt; from 4 to 3:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Nnode &amp;lt;- 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ordertree &amp;lt;- list(edge=edge, Nnode=Nnode, tip.label=tip.labels, edge.length=edge.length)
class(ordertree) &amp;lt;- &amp;#39;phylo&amp;#39;
plot(ordertree)
edgelabels(ordertree$edge.length, bg=&amp;quot;black&amp;quot;, col=&amp;quot;white&amp;quot;, font=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;…I was ready to go with an order-level tree onto which I could graft my individual phylogenies!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;node-dates&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Node dates&lt;/h3&gt;
&lt;p&gt;…Not so fast. I ended up with an additional problem I needed to solve before grafting the trees together. I ran into the error &lt;code&gt;&#39;split_age&#39; is inconsistent with edge lengths in &#39;phy&#39;&lt;/code&gt;, which means that the earliest node in one of my individual phylogenies was older than the node age I gave in &lt;code&gt;edge.length&lt;/code&gt;. By &lt;a href=&#34;https://babichmorrowc.github.io/post/debug-r/&#34;&gt;using &lt;code&gt;debug&lt;/code&gt;&lt;/a&gt;, I was able to tell that the error occurred when I added the squamate tree. The oldest node in my squamate tree was 277.8 million years ago, but I had set the divergence time between birds and squamates at 274.9 mya, so R was having problems. The species causing the problem was the tuatara, which is the only surviving member of its order.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:75%&#34; src=&#34;/img/tuatara.png&#34; /&gt;
&lt;figcaption&gt;
The pesky (yet very cute) tuatara (&lt;a href=&#34;https://www.australiangeographic.com.au/blogs/creatura-blog/2017/12/the-tuatara/&#34; class=&#34;uri&#34;&gt;https://www.australiangeographic.com.au/blogs/creatura-blog/2017/12/the-tuatara/&lt;/a&gt;)
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;I had a couple of choices: either delete the tuatara from the squamate phylogeny or increase the age of the last common ancestor of birds and squamates when I created the vector &lt;code&gt;edge.length&lt;/code&gt;. I chose to do the latter because why get rid of such a cool animal!&lt;/p&gt;
&lt;p&gt;I went to &lt;a href=&#34;http://timetree.org/&#34; class=&#34;uri&#34;&gt;http://timetree.org/&lt;/a&gt; to see if I could find a reasonable range of estimates for this node. According to the website, which allows you to search for the divergence time between any two taxa, the estimated divergence of birds and squamates occurred 280 mya.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:75%&#34; src=&#34;/img/timetree_birdsquamate.png&#34; /&gt;
&lt;figcaption&gt;
TimeTree results for divergence time of birds and squamates.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So I ended up with the following code and order tree:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tip.labels &amp;lt;- c(&amp;quot;amphib&amp;quot;, &amp;quot;squam&amp;quot;, &amp;quot;birds&amp;quot;, &amp;quot;mamm&amp;quot;)
edge &amp;lt;- matrix(c(7, 3,
  7, 2,
  6, 4,
  6, 7,
  5, 6,
  5, 1), byrow=TRUE, ncol=2)
edge.length &amp;lt;- c(280, 280, 324.5, 324.5-274.9, 382.9-324.5, 382.9)
Nnode &amp;lt;- 3
ordertree &amp;lt;- list(edge=edge, Nnode=Nnode, tip.label=tip.labels, edge.length=edge.length)
class(ordertree) &amp;lt;- &amp;#39;phylo&amp;#39;
plot(ordertree)
edgelabels(ordertree$edge.length, bg=&amp;quot;black&amp;quot;, col=&amp;quot;white&amp;quot;, font=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tree_list &amp;lt;- list(amphib=amphibiantree, birds=birdtree, squam=squamatetree, mamm=mammaltree)
class(tree_list) &amp;lt;- &amp;quot;multiPhylo&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;grafting-the-trees&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Grafting the trees&lt;/h2&gt;
&lt;p&gt;The final step is grafting the individual trees onto the order tree in the proper place.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Add taxonomic information to tree
otax &amp;lt;- data.frame(&amp;quot;Class&amp;quot;= ordertree$tip.label, &amp;quot;Superclass&amp;quot;=c(rep(&amp;quot;Tetrapoda&amp;quot;,2)))
rownames(otax) &amp;lt;- ordertree$tip.label
classtree &amp;lt;- nodelabel.phylo(ordertree, otax, ncores=1)

res &amp;lt;- glomogram.phylo(classtree, tree_list)
plot(res, type = &amp;quot;fan&amp;quot;, show.tip.label = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-01-09-grafting-trees_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Voila - a tree with 18262 species of tetrapods!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;disclaimer&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;I’d like to finish this post with a disclaimer: I am NOT a phylogeneticist (yet?). The supertree created in this analysis incorporates several different phylogenies from literature and adapts code from another published article (all written by people with much more phylogenetic background than I!). However, the accuracy of the tree decreases as you move back in time - there is a great deal of uncertainty about node age for the deeper nodes in the tree. Even so, this process allows us to make some cool visualizations to compare major clades across vast stretches of evolutionary time - even if precise dates are incorrect, overall patterns are still informative!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;code&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Code&lt;/h1&gt;
&lt;p&gt;The entire script I used for this process can be found at &lt;a href=&#34;https://github.com/KerkhoffLab/bodymasspatterns/blob/master/tetrapod_phylogeny_code.R&#34; class=&#34;uri&#34;&gt;https://github.com/KerkhoffLab/bodymasspatterns/blob/master/tetrapod_phylogeny_code.R&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;literature-cited&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Literature Cited&lt;/h1&gt;
&lt;p&gt;Alfaro, M. E., F. Santini, C. Brock, H. Alamillo, A. Dornburg, D. L. Rabosky, G. Carnevale, and L. J. Harmon. 2009. Nine exceptional radiations plus high turnover explain species diversity in jawed vertebrates. PNAS 106:13410-13414.&lt;/p&gt;
&lt;p&gt;Fritz, S. A., O. R. P. Bininda-Emonds, and A. Purvis. 2009. Geographical variation in predictors of mammalian extinction risk: big is bad, but only in the tropics. Ecology Letters 12:538–549.&lt;/p&gt;
&lt;p&gt;Jetz, W., G. H. Thomas, J. B. Joy, K. Hartmann, and A. O. Mooers. 2012. The global diversity of birds in space and time. Nature 491:444.&lt;/p&gt;
&lt;p&gt;O’Meara, B. C., L. J. Harmon, and J. Eastman. 2013. PhyloOrchard: Important and/or useful phylogenetic datasets.&lt;/p&gt;
&lt;p&gt;Pyron, R. A. and J. J. Wiens. 2011. A large-scale phylogeny of Amphibia including over 2800 species, and a revised classification of extant frogs, salamanders, and caecilians. Molecular Phylogenetics and Evolution 61: 543-583.&lt;/p&gt;
&lt;p&gt;Uyeda JC, Pennell MW, Miller ET, Maia R, McClain CR (2017) The evolution of energetic scaling across the vertebrate tree of life. The American Naturalist 190(2): 185-199. &lt;a href=&#34;https://doi.org/10.1086/692326&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1086/692326&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uyeda JC, Pennell MW, Miller ET, Maia R, McClain CR (2017) Data from: The evolution of energetic scaling across the vertebrate tree of life. Dryad Digital Repository. &lt;a href=&#34;https://doi.org/10.5061/dryad.3c6d2&#34; class=&#34;uri&#34;&gt;https://doi.org/10.5061/dryad.3c6d2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zheng, Y., and J. J. Wiens. 2016. Combining phylogenomic and supermatrix approaches, and a time-calibrated phylogeny for squamate reptiles (lizards and snakes) based on 52 genes and 4162 species. Molecular Phylogenetics and Evolution 94:537–547.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
