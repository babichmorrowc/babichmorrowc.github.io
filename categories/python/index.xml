<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python | Cecina Babich Morrow</title>
    <link>/categories/python/</link>
      <atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <description>Python</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>2022</copyright><lastBuildDate>Wed, 20 Feb 2019 21:13:14 -0500</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Python</title>
      <link>/categories/python/</link>
    </image>
    
    <item>
      <title>Hacking Meteorites Part 1: Calculating percent weights</title>
      <link>/post/2019-02-20-meteoritecluster1/</link>
      <pubDate>Wed, 20 Feb 2019 21:13:14 -0500</pubDate>
      <guid>/post/2019-02-20-meteoritecluster1/</guid>
      <description>


&lt;p&gt;Earlier this month I participated in the American Museum of Natural History’s annual hackathon (see my last &lt;a href=&#34;https://babichmorrowc.github.io/post/2019-02-14-hackathon/&#34;&gt;post&lt;/a&gt; for details about the event overall). During the hackathon, I worked with Katy Abbott, another Helen Fellow at the museum with me, to use a machine learning algorithm called DBSCAN to tackle our challenge. This post explains the process we used to complete the first step of the challenge: estimating the percent weights of elements in a meteorite.&lt;/p&gt;
&lt;div id=&#34;challenge-accepted&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Challenge accepted&lt;/h2&gt;
&lt;p&gt;Our team, consisting of Peter Kang, Jackson Lee, Jeremy Neiman, John Underwood, Katy Abbott, Meret Götschel, and myself, chose to work on the &lt;a href=&#34;https://github.com/amnh/HackTheSolarSystem/wiki/Meteorite-Mineral-Mapping&#34;&gt;Meteorite Mineral Mapping challenge&lt;/a&gt;. For this challenge, our museum stakeholders, Marina Gemma and Sam Alpert, wanted a way to identify the mineral composition of meteorites.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pixels-to-percents&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pixels to percents&lt;/h2&gt;
&lt;p&gt;The scientists scan meteorites with an electron microprobe, a device that provides the intensity of x-rays emitted from certain elements. The electron microprobe results in images with grayscale intensities corresponding to these x-ray intensities on a pixel-by-pixel basis.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;../../../static/img/meteorite_pixel_intensity.png&#34; /&gt;
&lt;figcaption&gt;
Images of a meteorite produced by the electron microprobe showing pixel intensities for each of 10 elements - brighter grayscale values indicate greater amounts of that element in a pixel.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Our first step was to convert these pixel intensities to the percent weight of each element in the mineral at that pixel. To do that, we referred to a set of standard images taken of minerals with a known proportion of each element. For example, the image below shows the pixel intensities of iron in 8 minerals: you can see that the pixels are brightest in Fe, or pure iron, and lower in iron oxide (&lt;span class=&#34;math inline&#34;&gt;\(\text{Fe}_3\text{O}_4\)&lt;/span&gt;) and troilite, or iron sulfide (FeS).&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;../../../static/img/iron_standard.png&#34; /&gt;
&lt;figcaption&gt;
Standard scan of the intensity of iron in each of 8 known minerals.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;We can relate the intensity of the iron pixels in the Fe mineral, for example, to the percent weight in that mineral (100%, since iron is the only element in Fe).&lt;/p&gt;
&lt;div id=&#34;import-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Import data&lt;/h3&gt;
&lt;p&gt;We started by creating a .csv file with the percent weight of each element in the minderals from the standards:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# import libraries
from sklearn.cluster import DBSCAN as dbscan
from sklearn.linear_model import LinearRegression
import pandas as pd
import numpy as np
from sklearn import metrics
import matplotlib.pyplot as plt
import matplotlib.colors
from sklearn.decomposition import PCA
from pathlib import Path
from skimage.io import imread, imshow
import numpy.ma as ma
from collections import Counter
# read in percent weights by element of the minerals in the standard
weights = pd.read_csv(&amp;quot;../../../static/mineralmapping/weights_to_minerals.csv&amp;quot;)
print(weights.head())
##        mineral  Mg     Ni  Al        Fe      Ca  Cr   P        S      Ti  Si
## 0  CaTiO3std15 NaN    NaN NaN       NaN  29.481 NaN NaN      NaN  35.211 NaN
## 1  Fe-num2std9 NaN    NaN NaN  100.0000     NaN NaN NaN      NaN     NaN NaN
## 2      FeSstd2 NaN    NaN NaN   63.5252     NaN NaN NaN  36.4748     NaN NaN
## 3   Fe3O4std15 NaN    NaN NaN   72.3591     NaN NaN NaN      NaN     NaN NaN
## 4       Nistd9 NaN  100.0 NaN       NaN     NaN NaN NaN      NaN     NaN NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note: I was able to add the above Python chunk in R by following &lt;a href=&#34;https://babichmorrowc.github.io/post/2019-02-20-pythonrmd/&#34;&gt;these instructions&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There is a linear relationship between pixel intensity and percent weight, so we used linear regression to find the slope of this relationship. We read in the .csv of pixel intensities for each element in the standards:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# read in the pixel intensities by element in the standard
mineral_standards = pd.read_csv(&amp;#39;../../../static/mineralmapping/mineral_standards.csv&amp;#39;)
print(mineral_standards.head())
##    Mg  Ni  Al  Fe   Ca  Cr  P  S   Ti  Si      mineral
## 0   0   0   0   0  171   0  4  0  459   0  CaTiO3std15
## 1   0   0   0   0  148   3  2  0  462   1  CaTiO3std15
## 2   0   2   0   0  141   6  3  0  455   2  CaTiO3std15
## 3   1   2   2   0  122   6  3  0  502   0  CaTiO3std15
## 4   0   0   0   0  138   5  5  0  457   1  CaTiO3std15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We modified the chemical formulas of each mineral using a dictionary by separating each element in the mineral with an “_&amp;quot; to make looping easier.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# create dictionary to standardize file names to chemical formulas
# needed to separate each element in the formula with an _ to make looping easier
mineral_dict = dict(zip(np.unique(mineral_standards[&amp;#39;mineral&amp;#39;]),
    [&amp;quot;Ca_Ti_O_3&amp;quot;, &amp;quot;Fe_&amp;quot;, &amp;quot;Fe_3O_4&amp;quot;, &amp;quot;Fe_S_&amp;quot;, &amp;quot;Ni_S_&amp;quot;, &amp;quot;Ni_&amp;quot;, &amp;quot;Ca_Fe_Mg_Mn_Ni_Si_&amp;quot;, &amp;quot;Ti_O_2&amp;quot;]))
# use dictionary to change mineral columns to underscore format
weights[&amp;#39;mineral&amp;#39;] = weights[&amp;#39;mineral&amp;#39;].map(mineral_dict)
mineral_standards[&amp;#39;mineral&amp;#39;] = mineral_standards[&amp;#39;mineral&amp;#39;].map(mineral_dict)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we created a list of the elements accounted for in the standards and made an empty dataframe called &lt;code&gt;coefs&lt;/code&gt; to fill with the coefficients of the relationship between pixel intensity and percent weight for each element:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# list of elements
# need to ignore the &amp;quot;mineral&amp;quot; column of the data
elements = [val for val in mineral_standards.columns if val != &amp;#39;mineral&amp;#39;]
coefs = pd.DataFrame(index = [&amp;#39;coeff&amp;#39;], columns = elements)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;linear-regressions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Linear regressions&lt;/h3&gt;
&lt;p&gt;Now we looped through the elements to create linear regressions of percent weight vs. pixel intensity based on the intensities in the standards. For these regressions, we forced the intercept to be zero because zero pixel intensity should imply zero percent weight.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# make a linear regression forcing the intercept to be zero
# since zero intensity should correspond to zero percent weight
lr = LinearRegression(fit_intercept = False)
# loop through elements to create linear regression of percent weight vs pixel intensity
# in the minerals in the standard
for element in elements:
    element_df = mineral_standards[mineral_standards[&amp;#39;mineral&amp;#39;].str.contains(element + &amp;quot;_&amp;quot;)]
    # if the element has no percent weights, skip it
    if element_df.empty:
        continue
    minerals = element_df[&amp;#39;mineral&amp;#39;].unique()
    xis = np.empty(0)
    yis = np.empty(0)
    for mine in minerals:
        # get percent weights of the element in that mineral
        weight = weights[weights[&amp;#39;mineral&amp;#39;] == mine][element]
        intensities = element_df[element_df[&amp;#39;mineral&amp;#39;] == mine][element]
        xis = np.append(xis, np.array(intensities))
        yis = np.append(yis, np.repeat(weight, len(intensities)))
    xis, yis = xis.reshape(-1,1), yis.reshape(-1,1)
    # fit linear regression on percent weight vs intensity
    reg = lr.fit(xis,yis)
    xi_pred =  np.arange(0,900).reshape(-1,1)
    # create predictions for range of intensity values
    pred = reg.predict(xi_pred)
    reg.coef_
    # get the linear regression coefficient for each element
    coefs[element] = float(reg.coef_)
# print the coefficients for each element
print(coefs)
##              Mg        Ni   Al        Fe  ...    P         S        Ti        Si
## coeff  0.118599  0.328796  NaN  0.320081  ...  NaN  0.469225  0.077627  0.097906
## 
## [1 rows x 10 columns]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus &lt;code&gt;coefs&lt;/code&gt; contains the coeficient relating pixel intensity of an element to its percent weight in the mineral: for example, the percent weight of Mg in an mineral is equal to 0.118599 times its pixel intensity.&lt;/p&gt;
&lt;figure&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:100%&#34; src=&#34;../../../static/img/mineral_regression.png&#34; /&gt;
&lt;figcaption&gt;
X-axes are pixel intensity and y-axes are percent weight of the element. Blue points indicate the pixel intensities of the element for a given percent weight based on a mineral in the standard. Orange points indicate the linear regression calculated above.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-percent-weights&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate percent weights&lt;/h3&gt;
&lt;p&gt;Finally, we used these coefficients to calculate the predicted percent weights of each element in the two meteorites we were analyzing on a pixel-by-pixel basis. The code for this portion of the analysis is available in the latter end of &lt;a href=&#34;https://github.com/HackTheSolarSystem/MineralMapping/blob/master/backend/mineral_mapping_script.py&#34;&gt;this script&lt;/a&gt;. Note that for any pixel where the percent weight of an element was predicted to be higher than 100%, we set the percent weight to 100%. From these calculations, we ended up with the following files:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# read file of predicted percent weights for meteorite 1
df_obj1 = pd.read_csv(&amp;#39;../../../static/mineralmapping/predicted_percentweight_obj1.csv&amp;#39;)
df_obj1 = df_obj1.fillna(0)
df_obj1.drop(&amp;#39;Unnamed: 0&amp;#39;, axis = 1, inplace = True)
print(df_obj1.head())
# read file of predicted percent weights for meteorite 2
##          Ca        Ti   Al   Cr  ...    P         Fe        Ni        Mg
## 0  8.595462  0.698642  0.0  0.0  ...  0.0  51.212925  0.986388  5.692734
## 1  4.512618  0.543388  0.0  0.0  ...  0.0  53.453490  1.972775  2.846367
## 2  2.578639  0.465761  0.0  0.0  ...  0.0  63.696075  3.287959  1.067388
## 3  2.148866  0.310508  0.0  0.0  ...  0.0  57.934621  3.945550  0.237197
## 4  1.719092  0.543388  0.0  0.0  ...  0.0  58.254702  3.616755  0.118599
## 
## [5 rows x 10 columns]
df_obj2 = pd.read_csv(&amp;#39;../../../static/mineralmapping/predicted_percentweight_obj2.csv&amp;#39;)
df_obj2 = df_obj2.fillna(0)
df_obj2.drop(&amp;#39;Unnamed: 0&amp;#39;, axis = 1, inplace = True)
print(df_obj2.head())
##           Si    P   Cr   Al  ...        Ca        Mg        Ni         Fe
## 0  22.322556  0.0  0.0  0.0  ...  0.429773  1.304585  4.931938  14.403635
## 1  11.650808  0.0  0.0  0.0  ...  0.000000  0.355796  2.630367  43.530986
## 2   4.601580  0.0  0.0  0.0  ...  0.429773  0.000000  1.643979  54.093652
## 3   2.349743  0.0  0.0  0.0  ...  0.000000  0.000000  0.986388  57.294460
## 4   0.783248  0.0  0.0  0.0  ...  0.000000  0.000000  1.315183  48.972359
## 
## [5 rows x 10 columns]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each row in these .csv files corresponds to a pixel in the original image. Each value gives the predicted percent weight of a given element in that pixel.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;up-next&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Up next&lt;/h2&gt;
&lt;p&gt;Now that we had converted pixel intensities to predicted percent weights, we were ready to use our clustering algorithm to identify potential minerals in the meteorite. Stay tuned for a future post showing how we used DBSCAN to accomplish this!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;further-reading&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;p&gt;Jeremy Neiman, one of my team members, wrote an excellent &lt;a href=&#34;https://towardsdatascience.com/machine-learning-meteorites-fcd8f6859ed7&#34;&gt;post&lt;/a&gt; describing the challenge in further detail, so check that out for more information.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Python in RMarkdown</title>
      <link>/post/2019-02-20-pythonrmd/</link>
      <pubDate>Wed, 20 Feb 2019 21:13:14 -0500</pubDate>
      <guid>/post/2019-02-20-pythonrmd/</guid>
      <description>


&lt;div id=&#34;using-python-in-rmarkdown&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using Python in RMarkdown&lt;/h2&gt;
&lt;p&gt;In order to write blog posts using Python code, I wanted to figure out a way to include Python code chunks in RMarkdowns. When you insert a code chunk in RMarkdown, you have the option of specifying the language of that chunk: the default is R, but you can also insert a Bash, SQL, Python, etc. code chunk.&lt;/p&gt;
&lt;p&gt;When I attempted to insert a Python code chunk and import libraries, however, I kept getting the error:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error in py_run_string_impl(code, local, convert) :&lt;/code&gt; &lt;code&gt;ImportError: No module named sklearn.cluster&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;From running Python in Atom, I knew I had the &lt;code&gt;sklearn.cluster&lt;/code&gt; module installed, so the problem must be in the connection between R and Python.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reticulate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;reticulate&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;reticulate&lt;/code&gt; package in R (website &lt;a href=&#34;https://rstudio.github.io/reticulate/index.html&#34;&gt;here&lt;/a&gt; allows R to interact with Python. I installed the package from RStudio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install.packages(&amp;quot;reticulate&amp;quot;)
library(reticulate)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;changing-python-versions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Changing Python versions&lt;/h2&gt;
&lt;p&gt;Installing &lt;code&gt;reticulate&lt;/code&gt; still didn’t allow me to knit the RMarkdown with a Python code chunk, however. I followed the instructions in &lt;a href=&#34;https://rstudio-pubs-static.s3.amazonaws.com/397064_bd288708515c4b71a6e78dfe91b8bb99.html&#34;&gt;this post&lt;/a&gt; by Pablo Franco to check the Python version that &lt;code&gt;reticulate&lt;/code&gt; was using:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;py_discover_config()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I ended up with the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python:         /usr/bin/python
libpython:      /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config/libpython2.7.dylib
pythonhome:     /System/Library/Frameworks/Python.framework/Versions/2.7:/System/Library/Frameworks/Python.framework/Versions/2.7
version:        2.7.10 (default, Aug 17 2018, 19:45:58)  [GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.0.42)]
numpy:          /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy
numpy_version:  1.8.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I wanted to be running Python version 3.6, which was the version I had installed using Anaconda, so I needed to change the path.&lt;/p&gt;
&lt;div id=&#34;set-up-chunk&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Set-up chunk&lt;/h3&gt;
&lt;p&gt;I discovered that you can set the path to a different installation of Python by modifying the setup chunk at the start of the RMarkdown. According to the &lt;a href=&#34;https://bookdown.org/yihui/rmarkdown/language-engines.html&#34;&gt;&lt;code&gt;bookdown&lt;/code&gt; website&lt;/a&gt;, the default used is Python 2.&lt;/p&gt;
&lt;p&gt;My default version of this set-up chunk looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can set the chunk option &lt;code&gt;engine.path&lt;/code&gt; to specify the path to the engine interpreter and change it from the default Python 2.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;finding-python-path&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Finding Python path&lt;/h3&gt;
&lt;p&gt;I now needed to find the actual path to Python that I wanted to use. I did this by opening up Python separately from RStudio (I used Atom for this) and running the following (I got the code for this from &lt;a href=&#34;https://www.dummies.com/programming/python/how-to-find-path-information-in-python/&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import sys
for p in sys.path:
    print(p)
## /Applications/anaconda3/bin
## /Applications/anaconda3/lib/python37.zip
## /Applications/anaconda3/lib/python3.7
## /Applications/anaconda3/lib/python3.7/lib-dynload
## /Applications/anaconda3/lib/python3.7/site-packages
## /Applications/anaconda3/lib/python3.7/site-packages/aeosa
## /Library/Frameworks/R.framework/Versions/3.5/Resources/library/reticulate/python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this information, I could tell I wanted to use the path &lt;code&gt;/anaconda3/lib/python3.6&lt;/code&gt;, rather than &lt;code&gt;/usr/bin/python&lt;/code&gt;, which is what RMarkdown had originally been using. I modified by set-up chunk to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, engine.path = list(python = &amp;#39;/anaconda3/bin/python3.6&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;other-options&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other options&lt;/h2&gt;
&lt;p&gt;This solution enabled me to knit RMarkdowns with Python code chunks! It changes the engine interpreter globally, which you could do for multiple engines simultaneously, like Python and Ruby, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;knitr::opts_chunk$set(engine.path = list(
  python = &amp;#39;/anaconda3/bin/python3.6&amp;#39;,
  ruby = &amp;#39;/usr/local/bin/ruby&amp;#39;
))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can specify the engine interpreter locally in each code chunk by starting the chunk with &lt;code&gt;{python, engine.path = &#39;/anaconda3/bin/python3.6&lt;/code&gt;}, for example.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
